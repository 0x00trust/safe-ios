//
//  File.swift
//  
//
//  Created by Dmitry Bespalov on 24.12.21.
//

import Foundation
import BigInt

protocol MUInt: UnsignedInteger, FixedWidthInteger {

}


// fixed width integer

// bit width can be greater than word size
    // can be multiple of word size
    // can be not multiple
// can be equal word size
// can be less than word size

// this gives us decision on the store.

// if it's > word size, we need multiple words
// otherwise we need one word.

// the bitwidth edge can be on the word width multiple
// or it can be different, misaligned.
// aligned with word size or misaligned with word size.

// in case it is misaligned, we need to adjust the algorithms
// to always keep the value correct.

extension MUInt {
    public var nonzeroBitCount: Int {
        words.map(\.nonzeroBitCount).reduce(0, +)
    }

    public var leadingZeroBitCount: Int {
        var count = 0
        for i in (0..<words.count).reversed() {
            count += words[i].leadingZeroBitCount
            if words[i] != 0 {
                break
            }
        }
        return count
    }

    public var trailingZeroBitCount: Int {
        var count = 0
        for i in (0..<words.count) {
            count += words[i].trailingZeroBitCount
            if words[i] != 0 {
                break
            }
        }
        return count
    }

    public var byteSwapped: Self {
        // collect each byte, then replay from reverse.
        let byteCount = (Self.bitWidth - 1) / 8 + 1
        let bytes = (0..<byteCount).map { UInt8(truncatingIfNeeded: (self >> $0 * 8) & 0xff) }
        var result: Self = 0
        for (offset, byte) in bytes.reversed().enumerated() {
            result |= Self(byte)
            result <<= offset * 8
        }
        return result
    }
}

// arithmetic methods not generated by compiler but they seem to be straightforward.
extension MUInt {
    public static func *= (lhs: inout Self, rhs: Self) {
        lhs = lhs * rhs
    }

    public static func /= (lhs: inout Self, rhs: Self) {
        lhs = lhs / rhs
    }

    public static func %= (lhs: inout Self, rhs: Self) {
        lhs = lhs % rhs
    }
}

// helpers
extension MUInt {
    static func mask() -> Self {
        Self(truncatingIfNeeded: UInt.max)
    }

    static func minWordCount() -> Int {
        (bitWidth - 1) / UInt.bitWidth + 1
    }
}

public struct MUInt200: MUInt {
    public static let bitWidth: Int = 200
//    static let bitMask: Self = mask()

    // TODO: 0b1 repeating for bitWidth bits
        // = max >> (bitWidth - Words.Element.bitWidth)
    static let wordCount: Int = minWordCount()
        // = (bitWidth - 1) / Words.Element.bitWidth + 1

    private(set) public var words: [UInt]

    // it will mask for the bitwidth
    init(words: [UInt]) {
        self.words = Array(words.prefix(Self.wordCount))
        self.words += [UInt](repeating: 0x00, count: Self.wordCount - self.words.count)
//        self &= Self.bitMask
    }

    public init(integerLiteral value: UInt) {
        self.init(words: [value])
    }

    public init(_truncatingBits value: UInt) {
        self.init(words: [value])
    }

    // arithmetic in terms of BigUInt
    public func addingReportingOverflow(_ rhs: MUInt200) -> (partialValue: MUInt200, overflow: Bool) {
        let a = BigUInt(words: words)
        let b = BigUInt(words: rhs.words)
        let c = a + b
        let overflow = c.bitWidth > Self.bitWidth
        let partialValue = Self(truncatingIfNeeded: c)
        return (partialValue, overflow)
    }

    public func subtractingReportingOverflow(_ rhs: MUInt200) -> (partialValue: MUInt200, overflow: Bool) {
        let a = BigUInt(words: words)
        let minusB = BigUInt(words: (~rhs).words) + 1
        let c = a + minusB
        let overflow = c > a
        let partialValue = Self(truncatingIfNeeded: c)
        return (partialValue, overflow)
    }

    public func multipliedReportingOverflow(by rhs: MUInt200) -> (partialValue: MUInt200, overflow: Bool) {
        let a = BigUInt(words: words)
        let b = BigUInt(words: rhs.words)
        let c = a * b
        let overflow = c.bitWidth > Self.bitWidth
        let partialValue = Self(truncatingIfNeeded: c)
        return (partialValue, overflow)
    }

    public func dividedReportingOverflow(by rhs: MUInt200) -> (partialValue: MUInt200, overflow: Bool) {
        if rhs == 0 {
            return (self, true)
        }
        let a = BigUInt(words: words)
        let b = BigUInt(words: rhs.words)
        let (c, _) = a.quotientAndRemainder(dividingBy: b)
        let partialValue = Self(truncatingIfNeeded: c)
        return (partialValue, false)
    }

    public func remainderReportingOverflow(dividingBy rhs: MUInt200) -> (partialValue: MUInt200, overflow: Bool) {
        if rhs == 0 {
            return (self, true)
        }
        let a = BigUInt(words: words)
        let b = BigUInt(words: rhs.words)
        let (_, c) = a.quotientAndRemainder(dividingBy: b)
        let partialValue = Self(truncatingIfNeeded: c)
        return (partialValue, false)
    }

    public func dividingFullWidth(_ dividend: (high: MUInt200, low: MUInt200)) -> (quotient: MUInt200, remainder: MUInt200) {
        let a = BigUInt(words: dividend.low.words + dividend.high.words)
        let b = BigUInt(words: words)
        let (q, r) = b.quotientAndRemainder(dividingBy: a)
        let overflow = q.bitWidth > Self.bitWidth
        precondition(!overflow)
        let result = (Self(truncatingIfNeeded: q), Self(truncatingIfNeeded: r))
        return result
    }
}

extension MUInt200 {
    // introduced in order to avoid infinite recursion in 'subtractin with overflow'
    // where we use two's complement
    prefix public static func ~ (x: Self) -> Self {
        Self(words: x.words.map(~))
    }

    // avoiding infinite recursion in distance(to:)
    public func distance(to other: MUInt200) -> MUInt200 {
        other - self
    }
}

extension MUInt200 {
    public static func &= (lhs: inout MUInt200, rhs: MUInt200) {
//        for i in (0..<lhs.words.count) {
//            lhs.words[i] &= rhs.words[i]
//        }
        // alternative:
        lhs.words = zip(lhs.words, rhs.words).map(&)
    }

    public static func |= (lhs: inout MUInt200, rhs: MUInt200) {
        lhs.words = zip(lhs.words, rhs.words).map(|)
    }

    public static func ^= (lhs: inout MUInt200, rhs: MUInt200) {
        lhs.words = zip(lhs.words, rhs.words).map(^)
    }
}

extension MUInt200 {
    // arithmetic in terms of 'reporting overflow'

    public static func * (lhs: MUInt200, rhs: MUInt200) -> MUInt200 {
        let c = lhs.multipliedReportingOverflow(by: rhs)
        precondition(!c.overflow)
        return c.partialValue
    }

    public static func + (lhs: MUInt200, rhs: MUInt200) -> MUInt200 {
        let c = lhs.addingReportingOverflow(rhs)
        precondition(!c.overflow)
        return c.partialValue
    }

    public static func - (lhs: MUInt200, rhs: MUInt200) -> MUInt200 {
        let c = lhs.subtractingReportingOverflow(rhs)
        precondition(!c.overflow)
        return c.partialValue
    }

    public static func / (lhs: MUInt200, rhs: MUInt200) -> MUInt200 {
        let c = lhs.dividedReportingOverflow(by: rhs)
        precondition(!c.overflow)
        return c.partialValue
    }

    public static func % (lhs: MUInt200, rhs: MUInt200) -> MUInt200 {
        let c = lhs.remainderReportingOverflow(dividingBy: rhs)
        precondition(!c.overflow)
        return c.partialValue
    }
}
